# -*- mode: makefile -*-
#

chk_upgrade:
	-@PETSC_DIR=${PETSC_DIR} ${PYTHON} ${PETSC_DIR}/lib/petsc/bin/petscnagupgrade.py

chklib_dir:
	@if [ ! -d "${INSTALL_LIB_DIR}" ]; then \
	  echo Making directory ${INSTALL_LIB_DIR} for library; ${MKDIR} ${INSTALL_LIB_DIR} ; fi

chkopts:
	-@echo "Warning: chkopts target is deprecated and can be removed from user makefiles"

gnumake:
	+@echo "make gnumake is deprecated, use make libs"
	+@make libs

${PETSC_DIR}/${PETSC_ARCH}/lib/petsc/conf/files:
	@touch -t 197102020000 ${PETSC_DIR}/${PETSC_ARCH}/lib/petsc/conf/files

${PETSC_DIR}/${PETSC_ARCH}/tests/testfiles:
	@${MKDIR} -p ${PETSC_DIR}/${PETSC_ARCH}/tests && touch -t 197102020000 ${PETSC_DIR}/${PETSC_ARCH}/tests/testfiles

libs: ${PETSC_DIR}/${PETSC_ARCH}/lib/petsc/conf/files ${PETSC_DIR}/${PETSC_ARCH}/tests/testfiles
	+@r=`echo "${MAKEFLAGS}" | grep ' -j'`; \
        if [ "$$?" = 0 ]; then make_j=""; else make_j="-j${MAKE_NP}"; fi; \
	r=`echo "${MAKEFLAGS}" | grep ' -l'`; \
        if [ "$$?" = 0 ]; then make_l=""; else make_l="-l${MAKE_LOAD}"; fi; \
        cmd="${OMAKE_PRINTDIR} -f gmakefile $${make_j} $${make_l} ${MAKE_PAR_OUT_FLG} V=${V} libs"; \
        cd ${PETSC_DIR} && echo $${cmd} && exec $${cmd}

# Removes garbage files
clean-legacy:
	@-${RM} ${CLEANFILES} ${TESTS} *.o *.lo *~ \
               ex[0-9] ex[0-9][0-9] ex[0-9][0-9][0-9] \
               ex[0-9]f ex[0-9][0-9]f ex[0-9][0-9][0-9]f \
               ex[0-9]k ex[0-9][0-9]k ex[0-9][0-9][0-9]k \
               ex[0-9]f90 ex[0-9][0-9]f90 ex[0-9][0-9][0-9]f90 \
               ex[0-9]cu ex[0-9][0-9]cu ex[0-9][0-9][0-9]cu \
               ex[0-9].exe ex[0-9][0-9].exe ex[0-9][0-9][0-9].exe \
               ex[0-9]f.exe ex[0-9][0-9]f.exe ex[0-9][0-9][0-9]f.exe \
               ex[0-9]f90.exe ex[0-9][0-9]f90.exe ex[0-9][0-9][0-9]f90.exe \
               ex[0-9]cu.exe ex[0-9][0-9]cu.exe ex[0-9][0-9][0-9]cu.exe \
               ex[0-9]hip ex[0-9][0-9]hip ex[0-9][0-9][0-9]hip \
               ex[0-9]hip.exe ex[0-9][0-9]hip.exe ex[0-9][0-9][0-9]hip.exe \
               ex[0-9]sycl ex[0-9][0-9]sycl ex[0-9][0-9][0-9]sycl \
               ex[0-9]sycl.exe ex[0-9][0-9]sycl.exe ex[0-9][0-9][0-9]sycl.exe \
              PI* *.ln l.outa* mputil.mp_* core core.* *.tmp *.map gmon.out *.gcov.html \
              trashz \#*\# *.mex* *.stolen *.trace Log.* *.stolen \
              output/*~ .mpirtmp mon.out *.aus *.mon.* p4pg ins10*.c \
               *.cp_ *.cp__ *.c*.c \
               *.dep *.proj ctoatmp PETScArena* *.L *.anl *.mod .mpi* *.d \
              *.class *.ouit *.ad.* g_* silly.cmp *.tmp.* *.ilk *.pdb *.inst.c *.rej *.gcda *.gcno
	@-${RM} -rf ${CLEANDIRS} *.dSYM AD_cache SunWS_cache

clean:: clean-legacy

getmpilinklibs:
	-@echo  ${MPI_LIB}

getmpiincludedirs:
	-@echo  ${MPI_INCLUDE}

# -----------------------------------------------------------------
getmpiexec:
	-@echo  ${MPIEXEC}

getccompiler:
	-@echo ${CC}

getfortrancompiler:
	-@echo ${FC}

getcxxcompiler:
	-@echo ${CXX}

getlinklibs:
	-@echo  ${C_SH_LIB_PATH} ${PETSC_TS_LIB}

getincludedirs:
	-@echo  ${PETSC_CC_INCLUDES}

getcflags:
	-@echo ${CC_FLAGS}

getcxxflags:
	-@echo ${CXX_FLAGS}

getfortranflags:
	-@echo ${FC_FLAGS}

getblaslapacklibs:
	-@echo ${BLASLAPACK_LIB}

getautoconfargs:
	-@echo CC='"${CC}"' CXX='"${CXX}"'  FC='"${FC}"' CFLAGS='"${CC_FLAGS}"' CXXFLAGS='"${CXX_FLAGS}"' FCFLAGS='"${FC_FLAGS}"' LIBS='"${C_SH_LIB_PATH} ${PETSC_TS_LIB}"'



# --------------------------------------------------------------------
#
# All remaining actions are intended for PETSc developers only.
# PETSc users should not generally need to use these commands.
#
#

.SUFFIXES: .F  .F90 .f90 ${SUFFIXES} .PETSc .C .cc .cpp .cxx .r .rm .so .html .ad .m .tex .make  .fig .svg .eps .pdf .jpg .png .dvi .ps .F95 .f95 .fiat .cu .hip.cpp .kokkos.cxx .raja.cxx *.sycl.cxx

#
#

.fig.pdf:
	fig2dev -L pdf $< $*.pdf
.fig.eps:
	fig2dev -L eps $< $*.eps
.fig.jpg:
	fig2dev -L jpeg $< $*.jpg
.pdf.jpg:
	convert $< $*.jpg
.eps.pdf:
	epstopdf $< -o=$*.pdf
.ps.pdf:
	ps2pdf $< $*.pdf
.dvi.ps:
	dvips -o $*.ps $<
.svg.png:
	inkscape --export-png=$*.png $<
.svg.pdf:
	inkscape --export-pdf=$*.pdf $<
# Need to define PYTHON
.fiat.h:
	@if [ "${ELEMENT}" != "" ]; then \
	  if [ "${ORDER}" != "" ]; then \
	    python $< $*.h --element_family=${ELEMENT} --element_order=${ORDER}; \
	  else \
	    python $< $*.h --element_family=${ELEMENT}; \
	  fi; \
	else \
	  if [ "${ORDER}" != "" ]; then \
	    python $< $*.h --element_order=${ORDER}; \
	  else \
	    python $< $*.h; \
	  fi; \
	fi

.c.o:
	-+@mypwd=`pwd`; newpwd=`echo $${mypwd} | sed "s+/tutorials+DUMMY+g"`;\
        if [ $${mypwd} != $${newpwd} ]; then \
	  ${OMAKE}  PETSC_ARCH=${PETSC_ARCH}  chk_petscdir;\
        fi
	${PETSC_COMPILE_SINGLE} `pwd`/$<

.cpp.o .cxx.o .cc.o .C.o:
	-+@mypwd=`pwd`; newpwd=`echo $${mypwd} | sed "s+/tutorials+DUMMY+g"`;\
        if [ $${mypwd} != $${newpwd} ]; then \
	  ${OMAKE}  PETSC_ARCH=${PETSC_ARCH}  chk_petscdir;\
        fi
	${PETSC_CXXCOMPILE_SINGLE} `pwd`/$<
#
#   Compiles CUDA code
.cu.o:
	${PETSC_CUCOMPILE_SINGLE} `pwd`/$<

.hip.cpp.o:
	${PETSC_HIPCOMPILE_SINGLE} `pwd`/$<

.kokkos.cxx.o:
	${PETSC_KOKKOSCOMPILE_SINGLE} `pwd`/$<

.sycl.cxx.o:
	${PETSC_SYCLCOMPILE_SINGLE} `pwd`/$<

.raja.cxx.o:
	${PETSC_RAJACOMPILE_SINGLE} `pwd`/$<

.F.o .F90.o .F95.o:
	${PETSC_FCOMPILE_SINGLE} `pwd`/$<

.f.o .f90.o .f95.o:
	${FC} -c ${FC_FLAGS} ${FFLAGS} -o $@ $<
#
#  These rules are for compiling the test examples.
#
.cpp.rm .cxx.rm .cc.rm .C.rm .F.rm .F90.rm .f.rm .c.rm .cu.rm:
	-@${RM} $* *.o $*.mon.* gmon.out mon.out
	-@${RM} *.exe *.ilk *.pdb *.tds
.cu.PETSc .hip.cpp.PETSc .kokkos.cxx.PETSc .c.PETSc .cxx.PETSc:
	-+@${OMAKE}  PETSC_ARCH=${PETSC_ARCH}  $* > trashz 2>&1
	-@grep -v clog trashz | grep -v "information sections" | \
          grep -v "warning C4003: not enough actual parameters for macro 'PETSC_PASTE3_" | \
          grep -v "(aka 'long \*') doesn't match specified 'MPI' type tag that requires 'long long \*'" | \
          grep -v "note: expanded from macro" |\
          grep -v "MPI_" | \
          grep -v "warnings generated" | \
          grep -v "WARNING: TOC" | \
          grep -v "D4024 : unrecognized" | \
          grep -v "tentative definition of size" | \
          grep -v "Extra instructions" | \
          grep -v "Unused external reference" | \
          grep -v "Warning: attribute unused is unsupported and will be skipped" | \
          grep -v "f90 continuing despite warning messages" | \
          grep -v "symbol if the" | \
          grep -v "ignoring symbol version info" | \
          grep -v "warning: initializer element is not computable at load time" | \
          grep -v "warning: ISO C90 forbids mixed declarations and code" | \
          grep -v "warning: ISO C90 does not support 'static' or type qualifiers in parameter array declarators" | \
          grep -v "warning, duplicate dylib" | \
          grep -v "warning: duplicate dylib" | \
          grep -v "preempts that definition" | \
          grep -v "is an array from" | \
	  grep -v "At least one PA 2.0" | \
          grep -v "Cannot cast" | \
          grep -v "WARNING 134: weak definition of" | \
          grep -v "Warning(s) detected" | \
          grep -v "object file assumed" | \
          grep -v "consider using mkstemp"  |\
          grep -v EXTERNAL  |\
          grep -v "warning prebinding disabled"  |\
          grep -v volatile  |\
          grep -v -i inconsistent |\
          grep -v Anachronism | \
          grep -v "/opt/ibmcmp/xlsmp/1.3/lib" | \
          grep -v "add line info to anonymous symbol" | \
          grep -v "/opt/ibmcmp/xlsmp/1.3/../.." | \
          grep -v "IPO Error: unresolved" | \
	  grep -v "is being replaced by a real definition" | \
          grep -v "may result in errors or" | \
          grep -v "is deprecated" | \
          grep -v "Werror=format-security" | \
          grep -v " -Werror " | \
          grep -v " was built for newer macOS version " | \
          grep -v "only the last is used because nvcc can only accept a single optimization setting" | \
	  grep -E -i '(Error|warning|Can|Unresolved)' >> /dev/null;\
	  if [ "$$?" != 1 ]; then \
          printf ${PETSC_TEXT_HILIGHT}"*******************Error detected during compile or link!*******************\n";\
          echo "See https://petsc.org/release/faq/";\
          echo ${PWD} $* ;\
          printf "*********************************************************************************"${PETSC_TEXT_NORMAL}"\n" ;\
	  cat trashz ; fi; ${RM} trashz

.F.PETSc .F90.PETSc:
	-+@${OMAKE}  PETSC_ARCH=${PETSC_ARCH}  $* > trashz 2>&1
	-@grep -v EXTERNAL trashz | grep -v Wall | \
          grep -v "warning: In-place macro substitution leaves line truncated" | \
          grep -v "Warning: Same actual argument associated with INTENT(IN) argument 'errorcode' and INTENT(OUT) argument 'ierror' at (1)" | \
          grep -v "Unused external reference" | \
          grep -v "D4024 : unrecognized" | \
          grep -v "WARNING: TOC overflow." | \
          grep -v "Extra instructions are being" | \
          grep -v "tentative definition of size" | \
          grep -v "symbol if the symbol" | \
          grep -v -i inconsistent | \
          grep -v -i "unused dummy" | \
          grep -v "alignment lost in merging tentative definition" | \
	  grep -v "WARNING:  -cpp is ignored" | \
          grep -v "ignoring symbol version info" | \
	  grep -v "At least one PA 2.0" | \
	  grep -v "Inconsistent structure" | \
          grep -v "object file assumed" | \
	  grep -v "ex20.F:30:" | \
	  grep -v "ex20f.F:31: warning" | \
	  grep -v "f90 continuing despite warning messages" | \
          grep -v "is an array from" | \
          grep -v "warning, duplicate dylib" | \
          grep -v "warning: duplicate dylib" | \
          grep -v "consider using mkstemp"  |\
          grep -v "Nonconforming tab character"  |\
	  grep -v "Unused external reference" | \
          grep -v "WARNING 134: weak definition of" | \
          grep -v 'continuing despite warning messages' | \
          grep -v "add line info to anonymous symbol" | \
          grep -v "warning prebinding disabled"  |\
          grep -v "ex20f.F:34: warning:" | \
	  grep -v "Unused dummy argument" | \
	  grep -v "is being replaced by a real definition" | \
          grep -v "IPO Error: unresolved" | \
          grep -v "warning multiple definitions of symbol _matdensegetarray_" | \
          grep -v "Werror=format-security" | \
          grep -v " -Werror " | \
          grep -v " was built for newer macOS version " | \
	  grep -E -i '(Error|warning|Can|Unresolved)'  >> /dev/null ; \
	  if [ "$$?" != 1 ]; then \
          printf ${PETSC_TEXT_HILIGHT}"*******************Error detected during compile or link!*******************\n";\
          echo "See https://petsc.org/release/faq/";\
          echo ${PWD} $* ;\
          printf "*********************************************************"${PETSC_TEXT_NORMAL}"\n" ;\
	  cat trashz ; fi; ${RM} trashz;

#--------------------------------------------------------------------------------------
remote_sshrsync:
	-@${RSYNC} makefile ${SOURCEALL} ${WORKMACHINE}:${WORKSPACE}
	-@echo ${SSH} ${WORKMACHINE} "cd ${WORKSPACE}; setenv PETSC_DIR ${WORKPETSCDIR} ; setenv PETSC_ARCH ${WORKPETSCARCH}; make ${EXECUTABLE}"
	-@${SSH} ${WORKMACHINE} "cd ${WORKSPACE}; setenv PETSC_DIR ${WORKPETSCDIR} ; setenv PETSC_ARCH ${WORKPETSCARCH}; make ${EXECUTABLE}"
	@IGNORE_THIS_ERROR

#---------------------------------------------------------------------------------------

deleteshared:
	@for LIBNAME in ${SHLIBS}; \
	do \
	   if [ -d ${INSTALL_LIB_DIR}/$${LIBNAME}.dylib.dSYM ]; then \
             echo ${RM} -rf ${INSTALL_LIB_DIR}/$${LIBNAME}.dylib.dSYM; \
	     ${RM} -rf ${INSTALL_LIB_DIR}/$${LIBNAME}.dylib.dSYM; \
	   fi; \
           echo ${RM} ${INSTALL_LIB_DIR}/$${LIBNAME}.${SL_LINKER_SUFFIX}; \
           ${RM} ${INSTALL_LIB_DIR}/$${LIBNAME}.${SL_LINKER_SUFFIX}; \
	done
	@if [ -f ${INSTALL_LIB_DIR}/so_locations ]; then \
          echo ${RM} ${INSTALL_LIB_DIR}/so_locations; \
          ${RM} ${INSTALL_LIB_DIR}/so_locations; \
	fi

# -------------------------------------------------------------------------------
#
# ----------------------------------------------------------------------------------------
# Coverage tests: what lines of source code are tested during running of test examples
#
# Removes files generated by gcov
#
cleangcov:
	-@find ${PETSC_DIR} -maxdepth 1 -name \*.gcov -delete
	-@find ${PETSC_DIR}/${PETSC_ARCH} -maxdepth 1 -name \*.gcov -delete
	-@find ${PETSC_DIR}/${PETSC_ARCH}/obj -name \*.gcov -delete
	-@find src -name \*.gcov -delete

cleangcovfull: cleangcov
	-@find ${PETSC_DIR}/${PETSC_ARCH}/obj -name \*.gcno -name \*.gcda -delete
#
#----------------------------------------------------------------------------------
checkbadPetscFunctionBegin:
	-@if [ "${SOURCED}" != "" ] ; then \
	${OMAKE} PETSC_ARCH=${PETSC_ARCH} \
	checkbadPetscFunctionBegin_private ; fi

GITSRC = '*.[chF]' '*.F90' '*.hpp' '*.cpp' '*.cxx' '*.cu' ${GITSRCEXCL}
GITSRCEXCL = \
':!*khash/*' \
':!*valgrind/*' \
':!*yaml/*' \
':!*perfstubs/*'
GITCFSRC = '*.[ch]' '*.hpp' '*.cpp' '*.cxx' '*.cu' ${GITSRCEXCL} ${GITCFSRCEXCL}
GITCFSRCEXCL = \
':!*petscversion.h' \
':!*mpif.h' \
':!*mpiunifdef.h' \
':!*finclude/*' \
':!systems/*' \
':!*benchmarks/*' \
':!*binding/*' \
':!*-custom/*' \
':!*f90-mod/*'

# Format all the source code in the given directory and down according to .clang_format
clangformat:
	-@git --no-pager ls-files -z ${GITCFSRC} | xargs -0 -P $(MAKE_NP) -L 10 clang-format -i

checkbadSource:
	@git --no-pager grep -n -P 'self\.gitcommit' -- config/BuildSystem/config/packages | grep 'origin/' ; if [[ "$$?" == "0" ]]; then echo "Error: Do not use a branch name in a configure package file"; false; fi
	-@${RM} -f checkbadSource.out
	-@echo "------Double blank lines in file -----------------------------------" > checkbadSource.out
	-@git --no-pager grep -n -P '^$$' -- ${GITSRC} > doublelinecheck.out
	-@${PYTHON} ${PETSC_DIR}/lib/petsc/bin/maint/doublelinecheck.py doublelinecheck.out >> checkbadSource.out
	-@${RM} -f doublelinecheck.out
	-@echo "------Tabs in file -------------------------------------------------" >> checkbadSource.out
	-@git --no-pager grep -n -P '\t' -- ${GITSRC} >> checkbadSource.out;true
	-@echo "------White space at end of line -----------------------------------" >> checkbadSource.out
	-@git --no-pager grep -n -P ' $$' -- ${GITSRC} >> checkbadSource.out;true
	-@echo "------Two ;; -------------------------------------------------------" >> checkbadSource.out
	-@git --no-pager grep -n -P -e ';;' -- ${GITSRC} | grep -v ' for (' >> checkbadSource.out;true
	-@echo "------PetscCall for an MPI error code ------------------------------" >> checkbadSource.out
	-@git --no-pager grep -n -P -e '= MPI[U]*_\w*\(.*PetscCall' -- ${GITSRC} | grep -v MPIU_File >> checkbadSource.out;true
	-@echo "------Missing if (ierr) return ierr; -------------------------------" >> checkbadSource.out
	-@git --no-pager grep -n -P -e 'ierr = PetscInitialize\(' -- '*.[ch]' '*.cpp' '*.cxx' '*.cu' | grep -v 'if (ierr) return ierr;' | grep -E "(test|tutorial)" >> checkbadSource.out;true
	-@echo "------DOS file (with DOS newlines) ---------------------------------" >> checkbadSource.out
	-@git --no-pager grep -n -P '\r' -- ${GITSRC} >> checkbadSource.out;true
	-@echo "------{ before SETERRQ ---------------------------------------------" >> checkbadSource.out
	-@git --no-pager grep -n -P '{SETERRQ' -- ${GITSRC} >> checkbadSource.out;true
	-@echo "------PetscCall following SETERRQ ----------------------------------" >> checkbadSource.out
	-@git --no-pager grep -n -P 'SETERRQ' -- ${GITSRC} | grep ";PetscCall" >> checkbadSource.out;true
	-@echo "------SETERRQ() without defined error code -------------------------" >> checkbadSource.out
	-@git --no-pager grep -n -P 'SETERRQ\((?!\))' -- ${GITSRC} | grep -v PETSC_ERR  | grep " if " | grep -v "__VA_ARGS__" | grep -v flow.c >> checkbadSource.out;true
	-@echo "------SETERRQ() with trailing newline ------------------------------" >> checkbadSource.out
	-@git --no-pager grep -n -P "SETERRQ[1-9]?.*\\\n\"" -- ${GITSRC} >> checkbadSource.out;true
	-@echo "------Define keyword used in test definition -----------------------" >> checkbadSource.out
	-@git --no-pager grep -n -P -e 'requires:.*define\(' -- ${GITSRC} >> checkbadSource.out;true
	-@echo "------No new line at end of file -----------------------------------" >> checkbadSource.out
	-@git --no-pager grep -n -P '[^\n]\z' -- ${GITSRC} >> checkbadSource.out;true
	-@echo "------Using if (condition) SETERRQ(...) instead of PetscCheck() ----" >> checkbadSource.out
	-@git --no-pager grep -n -P ' if +(.*) *SETERRQ' -- ${GITSRC} | grep -v 'PetscUnlikelyDebug' | grep -v 'petscerror.h' >> checkbadSource.out;true
	-@echo "------Using if (PetscUnlikelyDebug(condition)) SETERRQ(...) instead of PetscAssert()" >> checkbadSource.out
	-@git --no-pager grep -n -P -E ' if +\(PetscUnlikelyDebug.*\) *SETERRQ' -- ${GITSRC} | grep -v petscerror.h >> checkbadSource.out;true
	-@echo "------Using PetscFunctionReturn(ierr) ------------------------------" >> checkbadSource.out
	-@git --no-pager grep -n -P 'PetscFunctionReturn(ierr)' -- ${GITSRC} >> checkbadSource.out;true
	-@echo "------Defining a returning macro without PetscMacroReturns() -------" >> checkbadSource.out
	-@git --no-pager grep -n -P 'define .*\w+;\s+do' -- ${GITSRC} | grep -E -v '(PetscMacroReturns|PetscDrawCollectiveBegin|MatPreallocateBegin|PetscOptionsBegin|PetscObjectOptionsBegin|PetscOptionsHeadEnd)' >> checkbadSource.out;true
	-@echo "------Defining an error checking macro using CHKERR style ----------" >> checkbadSource.out
	-@git --no-pager grep -n -P 'define\s+CHKERR\w*\(.*\)\s*do\s+{' -- ${GITSRC} >> checkbadSource.out;true
	@a=`cat checkbadSource.out | wc -l`; l=`expr $$a - 18` ;\
         if [ $$l -gt 0 ] ; then \
           echo $$l " files with errors detected in source code formatting" ;\
           cat checkbadSource.out ;\
         else \
	   ${RM} -f checkbadSource.out;\
         fi;\
         test ! $$l -gt 0
	-@git --no-pager grep -P -n "[\x00-\x08\x0E-\x1F\x80-\xFF]" -- ${GITSRC} > badSourceChar.out;true
	-@w=`cat badSourceChar.out | wc -l`;\
         if [ $$w -gt 0 ] ; then \
           echo "Source files with non-ASCII characters ----------------" ;\
           cat badSourceChar.out ;\
         else \
	   ${RM} -f badSourceChar.out;\
         fi
	@test ! -s badSourceChar.out

#  The directories below contains files directly imported from an external package; they should not be directly edited or changed except to update from the package
checkbadFileChange:
	@git diff --stat --exit-code `lib/petsc/bin/maint/check-merge-branch.sh`..HEAD -- src/sys/yaml/src src/sys/yaml/include src/sys/yaml/License include/petsc/private/valgrind include/petsc/private/kash

vermin:
	@vermin -vvv -t=3.4- ${VERMIN_OPTIONS} ${PETSC_DIR}/config

lint:
	${PYTHON} ${PETSC_DIR}/lib/petsc/bin/maint/petsclinter --verbose=${V} --apply-patches=${REPLACE} $(LINTER_OPTIONS)

help-lint:
	@${PYTHON} ${PETSC_DIR}/lib/petsc/bin/maint/petsclinter --help
	-@echo "Basic usage:"
	-@echo "   make lint      <options>"
	-@echo "   make test-lint <options> <test only options>"
	-@echo
	-@echo "Options:"
	-@echo "  V=[1,0]                                Enable or disable verbose output"
	-@echo "  LINTER_OPTIONS=\"--opt1 --opt2 ...\"     See above for available options"
	-@echo
	-@echo "Test Only Options:"
	-@echo "  REPLACE=[1,0]                          Enable or disable replacing test output"
	-@echo

test-lint:
	${PYTHON} ${PETSC_DIR}/lib/petsc/bin/maint/petsclinter ${PETSC_DIR}/src/sys/tests/linter --test -j0 --werror --replace=${REPLACE} --verbose=${V} $(LINTER_OPTIONS)

check_petsc4py_rst:
	@${RM} -f petsc4py_rst.log
	@echo "Checking src/binding/petsc4py/DESCRIPTION.rst"
	@rst2html src/binding/petsc4py/DESCRIPTION.rst > /dev/null 2> petsc4py_rst.log
	@if test -s petsc4py_rst.log; then cat petsc4py_rst.log; exit 1; fi

# TODO: checkTestCoverage: that makes sure every tutorial test has at least one test listed in the file, perhaps handled by gmakegentest.py
# TODO: check for PetscBeginFunctionUser in non-example source
# TODO: check for __ at start of #define or symbol
# TODO: checking for missing manual pages
# TODO: check for incorrect %d
# TODO: check for double blank lines
# TODO: check for ill-formed manual pages
# TODO: check for { on line after for
# TODO: check for } then else on following line
# TODO: check for } else { with SETERRQ on following line or if () { with SETERRQ on following line

#  Lists all the URLs in the PETSc repository that are unaccessible, nonexistent, or permanently moved (301)
#  REPLACE=1 locations marked as permanently moved (301) are replaced in the repository
#  This code is fragile; always check the changes after a use of REPLACE=1 before committing the changes
#
#  Notes:
#    The first tr in the line is split lines for the cases where multiple URLs are in the same line
#    The first sed handles the case (http[s]*://xxx)
#    The list is sorted by length so that if REPLACE is used the longer apply before the shorter
#    The code recursively follows the permanently moved (301) redirections until it reaches the final URL
#    For DropBox we need to check the validity of the new URL but do not want to return to user the internal "raw" URL
checkbadURLS:
	-@x=`git grep "http[s]*://" -- '*.[chF]' '*.html' '*.cpp' '*.cxx' '*.cu' '*.F90' '*.py' '*.tex' | grep -E -v "(config/packages|HandsOnExercises)" | tr '[[:blank:]]' '\n' | grep 'http[s]*://' | sed 's!.*(\(http[s]*://[-a-zA-Z0-9_./()?=&+%~]*\))!\1!g' | sed 's!.*\(http[s]*://[-a-zA-Z0-9_./()?=&+%~]*\).*!\1!g' | sed 's/\.$$//g' | sort | uniq| awk '{ print length, $$0 }' | sort -r -n -s | cut -d" " -f2` ; \
        for i in $$x; do \
          url=$$i; \
          msg=''; \
          while [[ "$${msg}D" == "D" ]] ; do \
            y1=`curl --connect-timeout 5 --head --silent $${url} | head -n 1`; \
            y2=`echo $${y1} | grep ' 4[0-9]* '`; \
            y3=`echo $${y1} | grep ' 301 '`; \
            if [[ "$${y1}D" == "D" ]] ; then \
              msg="Unable to reach site" ; \
            elif [[ "$${y2}D" != "D" ]] ; then \
              msg=$${y1} ; \
            elif [[ "$${y3}D" != "D" ]] ; then \
              l=`curl --connect-timeout 5 --head --silent $${url} | grep ocation | sed 's/.*ocation:[[:blank:]]\(.*\)/\1/g' | tr -d '\r'` ; \
              w=`echo $$l | grep 'http'` ; \
              if [[ "$${w}D" != "D" ]] ; then \
                url=$$l ; \
              else \
                ws=`echo $${url} | sed 's!\(http[s]*://[-a-zA-Z0-9_.]*\)/.*!\1!g'` ; \
                dp=`echo $${ws}$${l} | grep "dropbox.com/s/raw"` ; \
                if [[ "$${dp}D" != "D" ]] ; then \
                  b=`curl --connect-timeout 5 --head --silent $${ws}$$l | head -n 1` ; \
                  c=`echo $${b} | grep -E "( 2[0-9]* | 302 )"` ; \
                  if [[ "$${c}D" == "D" ]] ; then \
                    msg=`echo "dropbox file doesn't exist" $${c}` ; \
                  else \
                    break ; \
                  fi; \
                else \
                  url="$${ws}$$l" ; \
                fi; \
              fi; \
            else \
              break; \
            fi; \
          done;\
          if [[ "$${msg}D" == "D" && "$${url}" != "$$i" ]] ; then \
            echo "URL" $$i "has moved to valid final location:" $${url} ; \
            if [[ "$${REPLACE}D" != "D" ]] ; then \
              git psed $$i $$l ;\
            fi; \
          elif [[ "$${msg}D" != "D" && "$${url}" != "$$i" ]] ; then \
            echo "ERROR: URL" $$i "has moved to invalid final location:" $${url} $${msg} ; \
          elif [[ "$${msg}D" != "D" ]] ; then \
            echo "ERROR: URL" $$i "invalid:" $${msg} ; \
          fi; \
        done

checkbadSpelling:
	-@x=`python3 ../bin/extract.py | aspell list | sort -u` ;

updatedatafiles:
	-@if [ -d "${HOME}/datafiles" ]; then \
            echo " ** Updating datafiles at ${HOME}/datafiles **"; \
            cd "${HOME}/datafiles" && git pull -q; fi

include ${PETSC_DIR}/lib/petsc/conf/rules.doc
